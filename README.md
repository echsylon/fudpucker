# Fudpucker
This project is a test bench for exploring different aspects of a distributed state repository.

The source code is implementing a peer client which knows how to send and receive packets. If a given packet can be acted on, the client will do so and propagate a change event, otherwise it will just relay the packet to some of it's known peers. The client is responsible not to spam peers with duplicates of any packet. Furthermore it is also required to be idempotent to received packets.

## How do ride this rodeo?
The peer client has two interface, one meant for you and the other meant for its peers. The interface meant for you is a basic REST API which is best consumed with an API client.

The interface designated for communicating with other peers is a raw byte-array based communication channel over UDP. You as a user can't do much to control this, but you can follow the log prints generated by the client.

## Tools
1. An ***API Client***. Bruno is recommended, there is even a convenient request collection in the source. You can get Bruno from here: https://www.usebruno.com/downloads
1. The ***Fudpucker*** artifact for your platform. This is what's referred to as "peer client" above. You can get it from the releases project page: https://github.com/echsylon/fudpucker/releases

## The work flow

The peer client is operable in two modes: *disconnected* mode and *connected* mode. While disconnected, the client can not sync it's state, nor can it receive updates on states from other peers. It can, however, create "devices" and modify the state of those devices that were created by you.

Once connected, the client will start of by sending a "hail" message, followed by a series of "sync" messages. The sync messages contains the full information for each device the peer knows of.

When connected, you can also request the owner of any device to change it's state. If you are the owner of said device, the client will change the state immediately and broadcast a "sync" message to some of it's peers (which will propagate the message to some *their* peers and so on). If you are *not* the owner of the device, the client will send a "patch" message to some of it's clients, requesting the change of state.

Furthermore, still while connected, the client can receive both "sync" and "patch" messages. A sync message will cause the client to update the corresponding device state if the packet contains newer information that what is already stored. A patch message will only be acted on if it addresses a devices which is owned by you, otherwise it will be propagated.

Finally, when disconnecting from the network, the client will broadcast a "farewell" message. All peers (your client included) are responsible to update their peers lists on hail and farewell messages.
